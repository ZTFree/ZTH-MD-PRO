# 大事件项目

> 文章管理系统项目



## 项目技术栈

- 核心
  - `Vue3`
  - `Vite`
  - `Pinia`
  - `VueRouter`
  - `ElementPlus`
- 其它
  - `eslint`
  - `pretty`
  - 等





---

# 知识点记录

## 插件

### pnpm的使用

> 比`npm`、`yarn`更优秀的包管理系统

- 语法
  - pnpm install 或 pnpm i
  - pnpm add xxx
  - pnpm add xxx -D
  - pnpm remove xxx
  - pnpm dev

- pnpm搭建vite+vue3脚手架

  ```powershell
  pnpm create vite
  或
  pnpm create vue
  ```





---

### eslint插件

- 环境同步

  - **安装了插件 `ESlint`，开启保存自动修复**

  - **禁用了插件 `Prettier`，并关闭保存自动格式化**

    - 平时自己开发时，记得重新打开

    ```js
    // ESlint插件 + Vscode配置 实现自动格式化修复
    "editor.codeActionsOnSave": {
        "source.fixAll": true
    },
    "editor.formatOnSave": false,
    ```

    

- 规则配置

  ```js
      rules: {
      'prettier/prettier': [
        'warn',
        {
          singleQuote: true, // 单引号
          semi: false, // 无分号
          printWidth: 80, // 每行宽度至多80字符
          trailingComma: 'none', // 不加对象|数组最后逗号
          endOfLine: 'auto' // 换行符号不限制（win mac 不一致）
        }
      ],
      'vue/multi-word-component-names': [
        'warn',
        {
          ignores: ['index'] // vue组件名称多单词组成（忽略index.vue）
        }
      ],
      'vue/no-setup-props-destructure': ['off'], // 关闭 props 解构的校验
      // 💡 添加未定义变量错误提示，create-vue@3.6.3 关闭，这里加上是为了支持下一个章节演示。
      'no-undef': 'error'
      }
  ```






---

### husky插件

> 全量检查
>
> add暂存修改时会检查并报出代码错误

- 初始化git仓库

- 初始化与安装

```
pnpm dlx husky-init
pnpm install
```

- 修改 `.husky/pre-commit` 文件

```
// 替换 npm test
pnpm lint
```

- 由于`eslint`的`lint`命令为全量检查，十分耗时，且会一同检查以往非自己所写的部分，故需要一个只检查自己提交的代码的解决方案

  

### lint-staged插件

> 只在`commit`阶段检查提交部分的代码并报出错误，不会检查历史错误

```powershell
pnpm i lint-staged -D
```

- 配置`pakcage.json`配置项

  ```json
  {
    "script":{
      "lint-staged":"lint-staged"
    },
    "lint-staged":{
      "*.{js,ts,vue}":[
        "eslint --fix"
      ]
    },
  }
  ```

- 再次修改`husky`命令

  ```
  pnpm lint-staged
  ```






---

## 初始化目录结构

> 删除初始化的默认文件

> 修改剩余代码内容

> 新增调整我们需要的目录结构

> 拷贝初始化资源文件，安装预处理器插件





---

## Vue3

### hooks的书写小坑

- 由于hooks不处于`Vue作用域`内，故`pinia`、`vue-router`的相关对象无法在hooks中导入获取，需要通过`外部传参`形式传入

### ref获取元素

- 若多个元素ref为同一值，但同一时刻只会存在其一（如v-if)则变量会响动态地获取dom元素

### 事件绑定多个方法

```vue
// 单个
<el-link @click="resetForm">← 登录</el-link>
<el-link @click="resetForm()">← 登录</el-link>

// 多个
<el-link @click="resetForm(), switchForm()">← 登录</el-link>
```

### import 引入媒体资源

```js
import avatar from '@/assets/default.png'
```

- avatar值为该图片在该项目中的相对路径    /big-event/src/assets/default.png



### ref代理复杂数据类型

- 若ref代理复杂数据类型，则对其value赋值对象引用，则会替换原始数据

```js
const userInfo = ref({})
userInfo.value = (await useGetUserInfoService()).data.data
```



### 插槽使用

```vue
//子组件
<template>
  <el-card class="page-container">
    <template #header>
      <div class="page-header">
        <!-- 必要不用插槽，可选用插槽，非通用则为普通插槽 -->
        <span>{{ title }}</span>
        <!-- 具名插槽 -->	
        <slot name="button"></slot>
      </div>
    </template>
    <!-- 普通插槽 -->
    <slot></slot>
  </el-card>
</template>
```



```vue
// 父组件
<PageContainer title="文章分类">
    // 具名插槽内容
    <template #extra>
      <el-button class="button" type="primary" @click="onAddChannel">
        添加分类
      </el-button>
    </template>
    // 默认插槽内容
    // 。。。。。。。。。
</PageContainer> 
```



### 组件向外暴露

> 属性均会进行解包失去响应式

#### `defineProps`：父组件向子组件暴露属性/方法

> 建议只用于暴露属性，方法使用自定义事件方式暴露

```vue
// 父组件
<template>
    // 子组件
    <ChildComponent :num='num' :fn='fn'></ChildComponent>
</template>

<script setup>
    const num = ref(0)
    const fn = ()=>{console.log(num.value)}
</script>
```

```vue
// 子组件
<script setup>
	import {defineProps} from 'vue'
	const props = defineProps(['num','fn'])
    console.log(props.num)
    props.fn()
</script>
```



#### `defineEmits`：父组件向子组件暴露方法（自定义事件）

```vue
// 父组件
<template>
    // 子组件
    <ChildComponent @doThing="fn"></ChildComponent>
</template>
<script setup>
    const fn = ()=>{console.log(num.value)}
</script>
```

```vue
// 子组件
<script setup>
	import {defineEmits} from 'vue'
	const emit = defineEmits(['doTing'])
    emit('doTing')
</script>
```



#### `defineExpose`：子组件向父组件暴露

```vue
// 父组件
<template>
    // 子组件
    <ChildComponent ref='cc'></ChildComponent>
</template>
<script setup>
    // 只要能获取子组件实例就行
    const cc = ref()
    console.log(cc.value.num)
    cc.value.fn()
</script>
```

```vue
// 子组件
<script setup>
	import {defineExpose} from 'vue'
    const num = ref(0)
	const fn = ()=>{console.log(num.value)}
    defineExpose({
        num,
        fn
    })
</script>
```

### v-model

- 在vue3中，v-model为对`:modelValue`和`@update:modelValue`的简写
- 在绑定`props`时要用`modelValue`，在绑定`emits`时要用`update`





---

## Vue-Router 4

###  语法补充

```js
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  // history模式
  history: createWebHistory(import.meta.env.BASE_URL),
  // hash模式
  // history: createWebHashHistory(import.meta.env.BASE_URL)
  routes: []
})

export default router
```

- 参数值为`import.meta.env.BASE_URL`
  - 该参数表示路由附带的默认前缀
  - `import.meta.env`为`vite`暴露的环境变量对象
    - `import.meta.env.BASE_URL`为`vite`的一个环境变量base

```
{
	base:"xxx"
}
```



### ElMessage组件样式错误

- 原因：可能为全局引入与局内引入命名产生了冲突
- 解决方案:修改eslint全局配置

```cjs
// .eslintrc.cjs
module.exports = {
  globals: {
    defineEmits: 'readonly',
    defineProps: 'readonly',
    defineExpose: 'readonly',
    withDefaults: 'readonly',
    WeixinJSBridge: 'readonly',
    ElMessage: 'readonly',
    ElMessageBox: 'readonly',
    ElLoading: 'readonly'
  }
}
```

### 内置`day.js`格式化时间库

- `Element-plus`组件库默认支持`day.js`进行日期时间处理，所以可以直接导入使用

```vue
<script>
    import { dayjs } from 'element-plus'
</script>
```



---

## Element-Plus

### 按需引入

1. 安装`element-plus`

```powershell
pnpm add element-plus
```

2. 选择按需自动导入

   1. 安装插件`unplugin-vue-components`和`unplugin-auto-import`

   ```powershell
   npm install -D unplugin-vue-components unplugin-auto-import
   ```

   

   2. 配置`Vite`的配置文件

   ```js
   // vite.config.ts
   import { defineConfig } from 'vite'
   import AutoImport from 'unplugin-auto-import/vite'
   import Components from 'unplugin-vue-components/vite'
   import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'
   
   export default defineConfig({
     // ...
     plugins: [
       // ...
       AutoImport({
         resolvers: [ElementPlusResolver()],
       }),
       Components({
         resolvers: [ElementPlusResolver()],
       }),
     ],
   })
   ```

3. 直接使用组件



### icon引入与使用

```vue
// 两种使用方法都用同一种引入方式进行按需引入
<template>
<el-input
  :prefix-icon="User"
  placeholder="请输入用户名"
/>

<el-icon><User /></el-icon>

</template>

<script>
import {
  User
} from '@element-plus/icons-vue'
</script>

```



### 中英语言处理Config Provider

- 默认是英文的，由于这里不涉及切换， 所以在 App.vue 中直接导入设置成中文即可

```vue

<template>
  <!-- 国际化处理 -->
  <el-config-provider :locale="zh">
    <router-view />
  </el-config-provider>
</template>

<script setup>
import zh from 'element-plus/es/locale/lang/zh-cn.mjs'
</script>
```



---

## Pinia

### Pinia Store定义语法之Setup Store语法

```js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

// 命名：useXxxStore
export const useNumStore = defineStore('num', () => {
  let num = ref(0)

  let dbNum = computed(() => {
    return num.value * 2
  })

  function addNum() {
    num.value++
  }
  function redNum() {
    num.value--
  }

  return {
    num,
    dbNum,
    addNum,
    redNum
  }
})
```

在 *Setup Store* 中：

- `ref()` 就是 `state` 属性
- `computed()` 就是 `getters`
- `function()` 就是 `actions`

 

### Pinia数据持久化（自动本地存储）

> 自动将state数据进行本地存储
>
> 注意：setup式数据要return才算是state

- 安装

```powershell
pnpm i pinia-plugin-persistedstate
```

- 配置

```js
// main.js

import persist from 'pinia-plugin-persistedstate'

app.use(createPinia().use(persist))
```

```js
// store.js
export const useStore = defineStore(
  'main',
  () => {
    const someState = ref('你好 pinia')
    return { someState }
  },
  {
    persist: true,
  },
)
```



###Pinia独立维护与仓库统一导出

```js
// main.js
import pinia from '@/stores'
app.use(pinia)

// stores/index.js
import { createPinia } from 'pinia'
import persist from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(persist)

// pinia独立维护
export default pinia

// 仓库统一导出
// 导入并导出
export * from './modules/num'
export * from './modules/user'
```





---

## Axios

### 配置Axios实例

```js
import axios from 'axios'
// 组合式API的好处，想在哪引入就在哪引入！！！
import {
  useUserStore
} from '@/stores'
// import { ElMessage as EM } from 'element-plus'
import {
  useRouter
} from 'vue-router'

const baseURL = 'http://big-event-vue-api-t.itheima.net'

const instance = axios.create({
  // TODO 1. 基础地址，超时时间
  baseURL,
  timeout: 10000
})

// 请求拦截器
instance.interceptors.request.use(
  (config) => {
    // TODO 2. 携带token
    config.headers.Authorization = useUserStore().token
    return config
  },

  (err) => Promise.reject(err)
)

// 响应拦截器
instance.interceptors.response.use(
  (res) => {
    // TODO 3. 处理业务失败
    // TODO 4. 摘取核心响应数据
    if (res.data.code === 0 || res.data.status === 0) {
      return res
    }
    // 弹窗提示
    ElMessage.error(res.data.message || 'error!!!')
    return Promise.reject(res.data)
  },
  (err) => {
    // TODO 5. 处理401错误 ==>权限不足 | token过期，拦截到登录
    if (err.response.status === 401) {
      useRouter().push('/login')
    }

    // 错误的默认情况
    ElMessage.error(err.response.data.message || 'error!!!')
    // 弹窗提示
    return Promise.reject(err)
  }
)

export default instance
export {
  baseURL
}
```

1. 基础地址，超时时间
2. 请求携带身份认证参数(token)
3. 根据文档处理一般失败响应
4. 处理特殊失败响应（401）





---

## 页面路由

- 一级路由

  - \login

  - \

    - 二级路由

      - article\channel
      - article\manage
      - user\profile
      - user\avatar

      - user\password


- 文件目录
  - views
    - layout
      
      - `LayoutContainer.vue`
      
        >  作用？
      
    - login
      - `LoginPage.vue`
      
    - article
      - `LoginPage.vue`
      - `ArticleChannel.vue`
      - `ArticleManage.vue`
      
    - user
      - `UserAvatar.vue`
      - `UserPassword.vue`
      - `UserProfile.vue`

### 路由书写

- 组件导入使用异步组件导入语法
  - `component: () => import('@/views/login/LoginPage.vue')`
- 路由重定向设置
  - `redirect: '/article/manage'`





---

## 登录注册页面

### 静态布局

1. 类名使用`小写单词连接法`格式

2. element-plus布局

   1. Layout网格布局：划分为24列的栅格模型

      1. span属性：占用列数
      2. offset属性：偏移列数

   2. Form表单

      1. size属性

   3. Input输入框

      1. prefix-icon属性配置icon

   4. Icon图标

      ```powershell
      pnpm install @element-plus/icons-vue
      ```



### 表单校验、重置

- 必要数据与属性

  1. `el-form`
    
     - :model="ruleForm" ==> {AA":....."}
     
     - :rules="rules" ==>{AA:[....]}

  2. `el-input`
     - v-model="ruleForm.AA"
  3. `el-form-item`
     - prop="AA"

- 校验规则

  - 类型
    1. 非空校验 `required`
       - 会使得表单label前带红色星星   <span style="color:red;">*</span>用户名
    2. 长度校验 `min`、`max`
    3. 正则校验 `pattern`
    4. 自定义校验 `validator`
       1. rule 该条规则相关信息
       2. value 表单值
       3. callback `回调函数`
          - 不传参 => 校验通过
          - 传入 Error对象 ==> 抛出错误信息
            - 若此时没设置message属性，则提示栏文字为错误信息
    
  - 提示信息 message
  
  - 触发时机 trigger


- 预校验
  - `validate`


```js
const formRef = ref()
const login = async () => {
  await formRef.value.validate()
  // 若校验不通过则不会执行后续代码
  console.log('注册中')
}
```

- 重置表单
  - `resetFields`


```js
const formRef = ref()
const resetForm = (isSwitch= false) => {
  if (!formRef.value) return
  if(isSwitch)  isRegister.value = !isRegister.value
  formRef.value.resetFields()
}
```



### 页面功能

#### 用户登录

- 封装api
- 登录页面调用

#### 用户注册

- 封装api
- 登录页面调用





---

## layout架子页面

### 布局

- 布局容器 Container
  - `el-container`
  - `el-aside`
  - `el-header`
  - `el-main`
  - `el-footer`
- 侧边菜单 Menu
  - `el-menu`
    - `default-active`    默认激活对应`index`值的item项
    - `router`    开启后，点击item会跳转至index对应的路由
  - `el-menu-item`
    - `index`    若index不以`/`开头，则会以当前路由作为父路由；否则，替换当前路由
  - `el-sub-menu`
- 主体头部下拉菜单 Dropdown
  - `el-dropdown`
    - `command事件`    在下拉菜单项被点击时触发对应方法，且接收一个值为下拉项`command`属性值的参数
    - `placement`    设置下拉菜单出现位置
  - `el-dropdown-menu`
  - `el-dropdown-item`
    - `command`    属性



### 全局路由守卫

- 防止无token进入非login路由
- `router.beforeEach`

```js
// router.js
router.beforeEach((to) => {
  const userStore = useUserStore()
  if (to.path !== '/login' && !userStore.token) {
    // 跳转中断，返回到from
    // return false

    // 重定向
    return '/login'
  }
})
```



### GET：用户信息获取

- 封装api
- 数据存储与userStore中并进行本地存储
- 获取信息并将其渲染至页面



### 用户登出体验优化

- 使用弹出消息框`ElMessageBox`来防止用户误操作

```js
// 用户登出确认
// 取消时会有error需要进行catch
try {
  // 内容 标题 配置对象
  await ElMessageBox.confirm('确定要退出登录?', '温馨提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  })
} catch (error) {
  return
}
```





---

## 功能模块架子组件

- components新建组件PageContainer
- 分析公共组成部分、可选部分与特有部分
  - 公共组成部分不需要使用插槽
  - 可选部分使用具名插槽
  - 特有部分使用普通插槽





---

## 文章分类页面

### 表格布局

- `el-table`

  - `data`    值为对象组成的数组，为表格数据
  - `v-loaging`    值为bool，表示是否显示加载中效果
  - `#empty` 空插槽   当数据为空时展示内部内容

- `el-table-column`

  - `type`    若为index，则会展示表格项序号
  - `label`  该列表格头
  - `prop`    数组中对象对象的键名
  - `width/min-width`    该列宽度/最小宽度 （px） 

  - `#default=“scope"`  自定义列插槽   接收以行信息对象，可自定义列内部内容

### 解决table的height无法自适应的问题

1. 为el-table用父盒子进行包裹，并且父盒子高度自适应
2. 所在el-card的card-body进行高度自适应
3. 组件挂载时获取table父盒子高度，并将其赋予到el-table的height值



### 模块API功能

#### 添加分类

- 不需要回显示

#### 编辑分类

- 需要回显内容（分类内容出现在表单中）



### Dialog组件化

- 父组件传入row信息用于dialog渲染，并且暴露更新数据方法
- 子组件向父组件暴露dialog显示方法

#### 



---

## 文章管理页面

#### 页面布局

- 搜索栏表单
- 文章信息表格
  - 默认插槽自定义表格项展示形式，且可以解构出row
  - element-plus自带`dayjs`库，看用`dayjs`变量名导入使用
- 分页器
  - 中英国际化处理
- 文章发布/编辑抽屉组件
  - 文章信息表单
  - 文件上传组件
  - 富文本组件





#### 上传封面图片文件 `el-upload`

1. 关闭自动上传，取消文件列表展示

2. 准备数据 和 选择图片的处理逻辑

   - File => URL

   - 将file对象转为`ObjectURL`，再交由img的src进行渲染

```jsx
const imgUrl = ref('')
const onUploadFile = (uploadFile) => {
  imgUrl.value = URL.createObjectURL(uploadFile.raw)
  formModel.value.cover_img = uploadFile.raw
}

// uploadFile.raw为对应的file对象
// 若为原生转换，则uploadFile.raw应替换为file对象
// 原生获取input:file的file=>inp.files
```

3. upload样式美化



#### 富文本编辑器  `vue-quill库`

官网地址：https://vueup.github.io/vue-quill/

1. 安装包

```js
pnpm add @vueup/vue-quill@latest
```

2. 注册成局部组件

```jsx
import { QuillEditor } from '@vueup/vue-quill'
import '@vueup/vue-quill/dist/vue-quill.snow.css'
```

3. 页面中使用绑定

```jsx
<div class="editor">
  <quill-editor
    theme="snow"
    v-model:content="formModel.content"
    contentType="html"
  >
  </quill-editor>
</div>
```

4. editor样式美化

```jsx
.editor {
  width: 100%;
  :deep(.ql-editor) {
    min-height: 200px;
  }
}
```



#### 添加文章功能

##### 对象转formdata

```js
// 转换 formData 数据
const fd = new FormData()
for (let key in formModel.value) {
fd.append(key, formModel.value[key])
}
```



#### 封面图片回显

- URL => File

##### URL=>File

```js
 const res = await artGetDetailService(row.id)
formModel.value = res.data.data
imgUrl.value = baseURL + formModel.value.cover_img
// 提交给后台，需要的是 file 格式的，将网络图片，转成 file 格式
// 网络图片转成 file 对象, 需要转换一下
formModel.value.cover_img = await imageUrlToFile(imgUrl.value, formModel.value.cover_img)
```

```js
// 将网络图片地址转换为File对象
async function imageUrlToFile(url, fileName) {
  try {
    // 第一步：使用axios获取网络图片数据
    const response = await axios.get(url, { responseType: 'arraybuffer' });
    const imageData = response.data;

    // 第二步：将图片数据转换为Blob对象
    const blob = new Blob([imageData], { type: response.headers['content-type'] });

    // 第三步：创建一个新的File对象
    const file = new File([blob], fileName, { type: blob.type });

    return file;
  } catch (error) {
    console.error('将图片转换为File对象时发生错误:', error);
    throw error;
  }
}
```

## 用户信息修改页面

- 用户头像（难度）
- 用户密码
- 用户昵称、email

### 用户头像

#### File=>64bit String

```js
const handleUploadFile = (file) => {
  // FileReader类型？
  const reader = new FileReader()
  reader.readAsDataURL(file.raw)
  reader.onload = () => {
    avatarUrl.value = reader.result
  }
}
```

- FileReader类型？







# 项目开发流程

## 一、初始环境配置

- 初始化git仓库
- vite脚手架搭建
- 调整编辑器插件与设置
- 依赖安装与配置
  - 代码检查
  - 代码格式化
  - ui组件库
  - 预处理库
- 脚手架目录及文件修改

## 二、功能开发

- api接口书写

- 路由层级分析与书写

  - 配置路由守卫

- 页面功能模块实现

  - 书写静态结构
  - 书写功能逻辑

  







## 开发细节

- 要做好路由守卫，防止以不合理方式访问路由
- 要做好axios请求封装，做好请求/响应拦截与错误处理
- `api接口`与`状态仓库`分模块书写，然后统一在`index`导入导出
- 代理对象，若需要完全替代，则推荐用`ref`代理，否则，尽量使用`reative`
- pinia本地存储需要导出的数据（return）才会生效
- export * from ’xxxxx' 可以实现当行导入并导出
- 若根路由无具体页面，则可通过重定向（redirect）到具体路由
- 路由导入组件使用动态导入法 component：( )=>import(路由地址)
- 活用UI组件的插槽，可以使内容展示更灵活
- 较少的样式尽量使用行内式
- 接口书写时，body数据用data表示，params数据用params表示，简单类型则用对应表示变量名
- 表单的非空校验、预校验要谨记！
- 若组件为路由模块里复用的，则该组件属于改模块的子模块组件modules中
- 若开发时无后端，则可以封装模拟数据api
- 为了良好的用户体验
  - 删除、注销、登出等操作要用确认框给予用户提示
  - 用时较长的异步操作要用显示Loading加载、Skeleton骨架屏等给用户看
  - 列表、表格无数据展示是要展示空内容插槽内容
  - 要为页面结构适当设置min-width，防止结构过度变形
  - 可适量使用图标提高页面美观度
  - 用户请求成功与失败都需要有提示
- 命名
  - api：useXxxService
  - 路由组件：路由分类+具体功能.vue
  - 事件处理函数：handleXxx（）
  - store仓库：useXxxStore
  - 表单
    - 数据：formModel
    - 校验规则：rules
    - 表单实例：formRef
  - 元素/组件实例：xxxRef



## 难点小记

1. 资源URL转File对象
2. 图片资源转64位字符串格式

